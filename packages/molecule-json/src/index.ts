/**
 * Convert between a molecule unpacked result and JSON ready JavaScript value.
 * @module
 * @example
 * ```ts
 * import * as json from "@ckb-cobuild/molecule-json";
 * JSON.stringify(
 *   json.toJson({a: 1}),
 * );
 * // => {"a": "0x1"}
 * ```
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { encodeHex, decodeHex } from "@ckb-cobuild/hex-encoding";
import {
  Codec,
  CodecError,
  DynamicSizeCodec,
  FixedSizeCodec,
} from "@ckb-cobuild/molecule";
import JSBI from "jsbi";

type CompatibleType = string | boolean | null;
type HexStringType = number | bigint | JSBI | Uint8Array;

/**
 * @example The corresponding Json value type of BuildingPacket
 * ```ts
 * JsonValue<BuildingPacket>
 * ```
 */
export type JsonValue<T> = T extends CompatibleType
  ? T
  : T extends undefined
    ? null
    : T extends HexStringType
      ? string
      : T extends Array<infer U>
        ? JsonArray<U>
        : JsonMap<T>;
type JsonArray<T> = Array<JsonValue<T>>;
type JsonMap<T> = {
  [K in keyof T]: JsonValue<T[K]>;
};

function prefix0x(hex: string): string {
  return !hex.startsWith("-") ? `0x${hex}` : `-0x${hex.slice(1)}`;
}

/**
 * Convert molecule unpack result to Json ready JavaScript value.
 *
 * The Json follows CKB JSONRPC convention which represents number, {@link JSBI}, bigint, Uint8Array as hex strings.
 * @param value - Unpack Result generated by Molecule Codecs unpack method.
 */
export function toJson<T = any>(value: T): JsonValue<T> {
  // Narrowing does not work here
  if (
    typeof value === "string" ||
    typeof value === "boolean" ||
    value === null
  ) {
    return value as JsonValue<T>;
  }
  if (typeof value === "number") {
    return prefix0x(value.toString(16)) as JsonValue<T>;
  }
  if (typeof value === "bigint") {
    return prefix0x(value.toString(16)) as JsonValue<T>;
  }
  if (typeof value === "object") {
    if (value instanceof JSBI) {
      return prefix0x(value.toString(16)) as JsonValue<T>;
    }
    if (value instanceof Uint8Array) {
      return `0x${encodeHex(value)}` as JsonValue<T>;
    }
    if (Array.isArray(value)) {
      return value.map(toJson) as JsonValue<T>;
    }

    const result: Record<string, any> = {};
    for (const [propertyName, propertyValue] of Object.entries(value)) {
      result[propertyName] = toJson(propertyValue);
    }
    return result as JsonValue<T>;
  }

  return (value !== undefined ? value : null) as JsonValue<T>;
}

/**
 * Create molecule codec which can parse 0x-prefix into number.
 * @example
 * ```ts
 * import * as json from "@ckb-cobuild/molecule-json";
 * import mol from "@ckb-cobuild/molecule";
 *
 * const Uint32 = json.createNumberJsonCodec(mol.Uint32);
 * Uint32.parse("0x1");
 * // => 1
 * ```
 */
export function createNumberJsonCodec(
  codec: FixedSizeCodec<number>,
): FixedSizeCodec<number, number | string>;
export function createNumberJsonCodec(
  codec: DynamicSizeCodec<number>,
): DynamicSizeCodec<number, number | string>;
export function createNumberJsonCodec(
  codec: Codec<number>,
): Codec<number, number | string> {
  return codec.beforeParse((input: number | string) =>
    typeof input === "number" ? input : parseInt(input, 16),
  );
}

/**
 * Create molecule codec which can parse 0x-prefix into Uint8Array.
 */
export function createUint8ArrayJsonCodec(
  codec: FixedSizeCodec<Uint8Array>,
): FixedSizeCodec<Uint8Array, Uint8Array | string>;
export function createUint8ArrayJsonCodec(
  codec: DynamicSizeCodec<Uint8Array>,
): DynamicSizeCodec<Uint8Array, Uint8Array | string>;
export function createUint8ArrayJsonCodec(
  codec: Codec<Uint8Array>,
): Codec<Uint8Array, Uint8Array | string> {
  return codec.beforeParse((input: Uint8Array | string) => {
    if (input instanceof Uint8Array) {
      return input;
    }
    if (typeof input === "string" && input.startsWith("0x")) {
      return decodeHex(input.slice(2));
    }

    throw CodecError.create(
      "parse",
      `Expect Uint8Array or 0x-prefix hex string`,
    );
  });
}

/**
 * Create molecule codec which can parse 0x-prefix into bigint.
 */
export function createBigIntJsonCodec(
  codec: FixedSizeCodec<bigint>,
): FixedSizeCodec<bigint, bigint | string>;
export function createBigIntJsonCodec(
  codec: DynamicSizeCodec<bigint>,
): DynamicSizeCodec<bigint, bigint | string>;
export function createBigIntJsonCodec(
  codec: Codec<bigint>,
): Codec<bigint, bigint | string> {
  return codec.beforeParse((input: bigint | string) => {
    if (typeof input === "bigint") {
      return input;
    }
    if (typeof input === "string") {
      if (input.startsWith("0x")) {
        return BigInt(input);
      }
      if (input.startsWith("-0x")) {
        return -BigInt(input.slice(1));
      }
    }

    throw CodecError.create("parse", `Expect bigint or 0x-prefix hex string`);
  });
}

/**
 * Create molecule codec which can parse 0x-prefix into JSBI.
 */
export function createJSBIJsonCodec(
  codec: FixedSizeCodec<JSBI>,
): FixedSizeCodec<JSBI, JSBI | string>;
export function createJSBIJsonCodec(
  codec: DynamicSizeCodec<JSBI>,
): DynamicSizeCodec<JSBI, JSBI | string>;
export function createJSBIJsonCodec(
  codec: Codec<JSBI>,
): Codec<JSBI, JSBI | string> {
  return codec.beforeParse((input: JSBI | string) => {
    if (input instanceof JSBI) {
      return input;
    }
    if (typeof input === "string") {
      if (input.startsWith("0x")) {
        return JSBI.BigInt(input);
      }
      if (input.startsWith("-0x")) {
        return JSBI.unaryMinus(JSBI.BigInt(input.slice(1)));
      }
    }

    throw CodecError.create("parse", `Expect JSBI or 0x-prefix hex string`);
  });
}
